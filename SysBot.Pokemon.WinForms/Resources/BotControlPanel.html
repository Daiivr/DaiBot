<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, maximum-scale=5.0">
    <title>DaiBot</title>
    <link rel="preload" href="favicon.png" as="image" type="image/png">
    <link rel="icon" href="favicon.png" type="image/png">
    <link rel="shortcut icon" href="favicon.png" type="image/png">
    <style>
        :root {
            --bg-primary: #0a0e27;
            --bg-secondary: #151932;
            --bg-card: #1e2139;
            --bg-hover: #252846;
            --text-primary: #ffffff;
            --text-secondary: #a8aec0;
            --accent: #7c3aed;
            --accent-hover: #6d28d9;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --border: #2d3054;
            --online: #10b981;
            --offline: #6b7280;
            --idle: #f59e0b;
            --shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            --shadow-hover: 0 8px 24px rgba(0, 0, 0, 0.4);
            --border-radius: 12px;
            --border-radius-sm: 8px;
            --spacing-xs: 0.25rem;
            --spacing-sm: 0.5rem;
            --spacing-md: 1rem;
            --spacing-lg: 1.5rem;
            --spacing-xl: 2rem;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
            font-size: clamp(14px, 2.5vw, 16px);
        }

        .app {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: rgba(21, 25, 50, 0.95);
            padding: var(--spacing-md) var(--spacing-lg);
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: var(--spacing-md);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            min-width: 0;
        }

            .logo h1 {
                font-size: clamp(1.25rem, 4vw, 1.5rem);
                font-weight: 700;
                color: var(--accent);
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--success);
            animation: pulse 2s infinite;
            flex-shrink: 0;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(16, 185, 129, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(16, 185, 129, 0);
            }
        }

        .refresh-status {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .refresh-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--success);
            transition: all 0.3s ease;
            cursor: help;
        }

            .refresh-indicator.paused {
                background: var(--warning);
                animation: pulse-warning 2s infinite;
            }

            .refresh-indicator:hover {
                transform: scale(1.5);
            }

        @keyframes pulse-warning {
            0% {
                box-shadow: 0 0 0 0 rgba(245, 158, 11, 0.7);
            }

            70% {
                box-shadow: 0 0 0 8px rgba(245, 158, 11, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(245, 158, 11, 0);
            }
        }

        .main {
            flex: 1;
            padding: var(--spacing-lg);
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
        }

        .global-controls {
            background: var(--bg-card);
            border-radius: var(--border-radius);
            padding: var(--spacing-lg);
            margin-bottom: var(--spacing-xl);
            border: 1px solid var(--border);
        }

            .global-controls h2 {
                font-size: clamp(1rem, 3vw, 1.2rem);
                margin-bottom: var(--spacing-md);
                color: var(--text-secondary);
            }

        .control-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: var(--spacing-sm);
        }

        .btn {
            padding: var(--spacing-sm) var(--spacing-md);
            border: none;
            border-radius: var(--border-radius-sm);
            font-size: clamp(0.75rem, 2.5vw, 0.875rem);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--spacing-xs);
            background: var(--bg-hover);
            color: var(--text-primary);
            border: 1px solid var(--border);
            position: relative;
            overflow: hidden;
            min-height: 44px;
            white-space: nowrap;
            text-decoration: none;
        }

            .btn:hover:not(:disabled) {
                transform: translateY(-2px);
                box-shadow: var(--shadow);
            }

            .btn:active {
                transform: translateY(0);
            }

            .btn:disabled {
                opacity: 0.5;
                cursor: not-allowed;
                transform: none !important;
            }

        .btn-primary {
            background: var(--accent);
            border-color: var(--accent);
        }

            .btn-primary:hover:not(:disabled) {
                background: var(--accent-hover);
            }

        .btn-success {
            background: var(--success);
            border-color: var(--success);
        }

        .btn-warning {
            background: var(--warning);
            border-color: var(--warning);
            color: #000;
        }

        .btn-danger {
            background: var(--danger);
            border-color: var(--danger);
        }

        .instances-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(min(100%, 350px), 1fr));
            gap: var(--spacing-lg);
        }

        .instance-card {
            background: var(--bg-card);
            border-radius: var(--border-radius);
            border: 1px solid var(--border);
            overflow: hidden;
            transition: all 0.3s ease;
            position: relative;
        }

            .instance-card.online {
                border-color: var(--online);
            }

            .instance-card.offline {
                opacity: 0.7;
                border-color: var(--offline);
            }

            .instance-card:hover {
                transform: translateY(-4px);
                box-shadow: var(--shadow-hover);
            }

        .instance-header {
            background: var(--bg-secondary);
            padding: var(--spacing-md) var(--spacing-lg);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            border-bottom: 1px solid var(--border);
            gap: var(--spacing-sm);
        }

        .instance-title {
            font-size: clamp(0.95rem, 3vw, 1.1rem);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            min-width: 0;
            flex: 1;
        }

        .instance-badge {
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            background: var(--bg-hover);
            color: var(--text-secondary);
            white-space: nowrap;
            flex-shrink: 0;
        }

        .instance-body {
            padding: var(--spacing-lg);
        }

        .instance-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-lg);
        }

        .info-item {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xs);
        }

        .info-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .info-value {
            font-size: 0.95rem;
            font-weight: 600;
            word-break: break-word;
        }

        .bot-status {
            display: grid;
            grid-template-columns: 1fr;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-md);
            padding: var(--spacing-sm);
            background: var(--bg-hover);
            border-radius: var(--border-radius-sm);
        }

        .bot-status-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 0.875rem;
            padding: var(--spacing-xs) 0;
            gap: var(--spacing-sm);
        }

            .bot-status-item .bot-name {
                display: flex;
                align-items: center;
                gap: var(--spacing-sm);
                min-width: 0;
                flex: 1;
            }

                .bot-status-item .bot-name span:first-child {
                    flex-shrink: 0;
                }

                .bot-status-item .bot-name span:last-child {
                    word-break: break-word;
                    overflow: hidden;
                    text-overflow: ellipsis;
                }

            .bot-status-item .bot-state {
                font-weight: 600;
                padding: var(--spacing-xs) var(--spacing-sm);
                border-radius: 4px;
                font-size: 0.75rem;
                white-space: nowrap;
                flex-shrink: 0;
            }

        .bot-state.running {
            background: rgba(16, 185, 129, 0.2);
            color: var(--success);
        }

        .bot-state.stopped {
            background: rgba(239, 68, 68, 0.2);
            color: var(--danger);
        }

        .bot-state.idle {
            background: rgba(245, 158, 11, 0.2);
            color: var(--idle);
        }

        .bot-state.error {
            background: rgba(239, 68, 68, 0.2);
            color: var(--danger);
        }

        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 200px;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .error-message {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid var(--danger);
            border-radius: var(--border-radius-sm);
            padding: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--danger);
            display: flex;
            align-items: flex-start;
            gap: var(--spacing-sm);
            word-break: break-word;
        }

        .toast {
            position: fixed;
            bottom: var(--spacing-xl);
            right: var(--spacing-xl);
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: var(--border-radius-sm);
            padding: var(--spacing-md) var(--spacing-lg);
            box-shadow: var(--shadow-hover);
            transform: translateX(calc(100% + var(--spacing-xl)));
            transition: transform 0.3s ease;
            z-index: 10000;
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            max-width: min(400px, calc(100vw - 2rem));
            word-break: break-word;
            opacity: 1;
        }

            .toast.show {
                transform: translateX(0);
            }

            .toast.success {
                border-color: var(--success);
                background: var(--bg-card);
            }

            .toast.error {
                border-color: var(--danger);
                background: var(--bg-card);
            }

            .toast.warning {
                border-color: var(--warning);
                background: var(--bg-card);
            }

            .toast.info {
                border-color: var(--accent);
                background: var(--bg-card);
            }

        .toast-icon {
            font-size: 1.25rem;
            flex-shrink: 0;
        }

        .online-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--online);
            display: inline-block;
            margin-right: var(--spacing-sm);
            flex-shrink: 0;
        }

        .offline-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--offline);
            display: inline-block;
            margin-right: var(--spacing-sm);
            flex-shrink: 0;
        }

        .instance-status-badge {
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            white-space: nowrap;
        }

            .instance-status-badge.running {
                background: rgba(16, 185, 129, 0.2);
                color: var(--success);
                border: 1px solid var(--success);
            }

            .instance-status-badge.stopped {
                background: rgba(239, 68, 68, 0.2);
                color: var(--danger);
                border: 1px solid var(--danger);
            }

            .instance-status-badge.idle {
                background: rgba(245, 158, 11, 0.2);
                color: var(--idle);
                border: 1px solid var(--idle);
            }

            .instance-status-badge.mixed {
                background: rgba(168, 174, 192, 0.2);
                color: var(--text-secondary);
                border: 1px solid var(--text-secondary);
            }

        .instance-controls {
            position: relative;
        }

        .action-menu-button {
            padding: var(--spacing-sm) var(--spacing-md);
            background: var(--bg-hover);
            border: 1px solid var(--border);
            border-radius: var(--border-radius-sm);
            color: var(--text-primary);
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
            width: 100%;
            justify-content: center;
            min-height: 44px;
        }

            .action-menu-button:hover:not(:disabled) {
                background: var(--accent);
                border-color: var(--accent);
                transform: translateY(-1px);
                box-shadow: var(--shadow);
            }

            .action-menu-button:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }

        .action-menu {
            position: absolute;
            bottom: calc(100% + var(--spacing-xs));
            left: 0;
            right: 0;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: var(--border-radius-sm);
            box-shadow: var(--shadow-hover);
            overflow: hidden;
            display: none;
            z-index: 1000;
        }

            .action-menu.show {
                display: block;
            }

        .action-menu-item {
            padding: var(--spacing-sm) var(--spacing-md);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            cursor: pointer;
            transition: background 0.2s ease;
            font-size: 0.875rem;
            white-space: nowrap;
            border: none;
            background: none;
            color: var(--text-primary);
            width: 100%;
            text-align: left;
        }

            .action-menu-item:hover {
                background: var(--bg-hover);
            }

            .action-menu-item.success {
                color: var(--success);
            }

            .action-menu-item.warning {
                color: var(--warning);
            }

            .action-menu-item.danger {
                color: var(--danger);
            }

        .action-menu-divider {
            height: 1px;
            background: var(--border);
            margin: var(--spacing-xs) 0;
        }

        @media (max-width: 1024px) {
            .instances-grid {
                grid-template-columns: repeat(auto-fill, minmax(min(100%, 300px), 1fr));
            }
        }

        @media (max-width: 768px) {
            :root {
                --spacing-lg: 1rem;
                --spacing-xl: 1.5rem;
            }

            .header {
                padding: var(--spacing-md);
            }

            .header-content {
                flex-wrap: wrap;
            }

            .refresh-status {
                order: 3;
                width: 100%;
                justify-content: center;
                margin-top: var(--spacing-sm);
            }

            .main {
                padding: var(--spacing-md);
            }

            .instances-grid {
                grid-template-columns: 1fr;
                gap: var(--spacing-md);
            }

            .control-buttons {
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
                gap: var(--spacing-xs);
            }

            .instance-info {
                grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
                gap: var(--spacing-sm);
            }

            .instance-header {
                padding: var(--spacing-md);
                flex-direction: column;
                align-items: flex-start;
                gap: var(--spacing-sm);
            }

            .instance-title {
                width: 100%;
            }

            .bot-status-item {
                flex-direction: column;
                align-items: flex-start;
                gap: var(--spacing-xs);
            }

                .bot-status-item .bot-name {
                    width: 100%;
                }

            .toast {
                bottom: 0;
                right: 0;
                left: 0;
                max-width: none;
                transform: translateY(100%);
                border-radius: var(--border-radius-sm) var(--border-radius-sm) 0 0;
                margin: 0;
            }

                .toast.show {
                    transform: translateY(0);
                }

            .action-menu {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                top: auto;
                border-radius: var(--border-radius) var(--border-radius) 0 0;
                max-height: 70vh;
                overflow-y: auto;
            }
        }

        @media (max-width: 480px) {
            .control-buttons {
                grid-template-columns: 1fr 1fr;
            }

            .btn {
                font-size: 0.75rem;
                padding: var(--spacing-sm);
            }

            .global-controls {
                padding: var(--spacing-md);
            }

            .instance-body {
                padding: var(--spacing-md);
            }

            .logo h1 {
                font-size: 1.1rem;
            }
        }

        @media (hover: none) and (pointer: coarse) {
            .btn:hover {
                transform: none;
                box-shadow: none;
            }

            .instance-card:hover {
                transform: none;
                box-shadow: none;
            }

            .action-menu-button:hover {
                transform: none;
            }
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10000;
            backdrop-filter: blur(4px);
            animation: fadeIn 0.3s ease;
        }

        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: var(--spacing-lg);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .modal-content {
            background: var(--bg-card);
            border-radius: var(--border-radius);
            border: 1px solid var(--border);
            max-width: 600px;
            width: 100%;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            box-shadow: var(--shadow-hover);
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-20px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .progress-modal-content {
            max-width: 700px;
        }

        .modal-header {
            padding: var(--spacing-lg);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

            .modal-header h2 {
                margin: 0;
                font-size: 1.5rem;
                color: var(--accent);
            }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

            .modal-close:hover {
                background: var(--bg-hover);
                color: var(--text-primary);
            }

        .modal-body {
            padding: var(--spacing-lg);
            overflow-y: auto;
            flex: 1;
        }

        .modal-footer {
            padding: var(--spacing-lg);
            border-top: 1px solid var(--border);
            display: flex;
            gap: var(--spacing-sm);
            justify-content: flex-end;
        }

        .update-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-md);
            padding: var(--spacing-lg);
            background: var(--bg-hover);
            border-radius: var(--border-radius-sm);
            margin-bottom: var(--spacing-lg);
        }

        .version-info {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xs);
            align-items: center;
            text-align: center;
        }

        .version-label {
            font-size: 0.875rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .version-value {
            font-size: 1.25rem;
            font-weight: 700;
            font-family: monospace;
        }

        .version-new {
            color: var(--success);
        }

        .changelog-section h3 {
            margin: 0 0 var(--spacing-md) 0;
            color: var(--text-secondary);
            font-size: 1.1rem;
        }

        .changelog-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: var(--border-radius-sm);
            padding: var(--spacing-md);
            max-height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.875rem;
            line-height: 1.6;
            white-space: pre-wrap;
        }

        .progress-step {
            display: flex;
            align-items: flex-start;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-lg);
        }

        .step-icon {
            font-size: 2rem;
            flex-shrink: 0;
        }

        .step-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: var(--spacing-xs);
        }

        .step-details {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .progress-bar-container {
            height: 8px;
            background: var(--bg-hover);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: var(--spacing-lg);
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--accent) 0%, var(--accent-hover) 100%);
            width: 0%;
            transition: width 0.5s ease;
            position: relative;
            overflow: hidden;
        }

            .progress-bar::after {
                content: '';
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: linear-gradient( 90deg, transparent 0%, rgba(255, 255, 255, 0.2) 50%, transparent 100% );
                animation: shimmer 2s infinite;
            }

        @keyframes shimmer {
            0% {
                transform: translateX(-100%);
            }

            100% {
                transform: translateX(100%);
            }
        }

        .idle-status {
            background: var(--bg-hover);
            border-radius: var(--border-radius-sm);
            padding: var(--spacing-lg);
            margin-bottom: var(--spacing-lg);
        }

        .idle-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        .idle-stat {
            text-align: center;
        }

        .idle-number {
            font-size: 2rem;
            font-weight: 700;
            color: var(--accent);
            margin-bottom: var(--spacing-xs);
        }

        .idle-label {
            font-size: 0.875rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .bot-details {
            margin-top: var(--spacing-md);
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .bot-detail-item {
            padding: var(--spacing-xs);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .update-log {
            max-height: 200px;
            overflow-y: auto;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: var(--border-radius-sm);
            padding: var(--spacing-md);
            font-family: monospace;
            font-size: 0.8rem;
            line-height: 1.4;
        }

        .log-entry {
            padding: var(--spacing-xs) 0;
            border-bottom: 1px solid var(--border);
        }

            .log-entry:last-child {
                border-bottom: none;
            }

        .log-time {
            color: var(--text-secondary);
            margin-right: var(--spacing-sm);
        }

        .log-success {
            color: var(--success);
        }

        .log-error {
            color: var(--danger);
        }

        .log-warning {
            color: var(--warning);
        }

        .progress-bar.indeterminate {
            animation: indeterminate 2s linear infinite;
            background: linear-gradient( 90deg, transparent 0%, var(--accent) 50%, transparent 100% );
        }

        @keyframes indeterminate {
            0% {
                transform: translateX(-100%);
            }

            100% {
                transform: translateX(100%);
            }
        }

        .reconnect-status {
            background: var(--bg-hover);
            border: 2px solid var(--warning);
            border-radius: var(--border-radius-sm);
            padding: var(--spacing-lg);
            margin-top: var(--spacing-lg);
            text-align: center;
            animation: pulse-border 2s infinite;
        }

        @keyframes pulse-border {
            0%, 100% {
                border-color: var(--warning);
            }

            50% {
                border-color: var(--accent);
            }
        }

        .reconnect-icon {
            font-size: 3rem;
            margin-bottom: var(--spacing-md);
            animation: spin 2s linear infinite;
        }

        .reconnect-text {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: var(--spacing-sm);
            color: var(--warning);
        }

        .reconnect-hint {
            font-size: 0.875rem;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        @media (max-width: 768px) {
            .modal-content {
                max-height: 100vh;
                margin: 0;
                border-radius: 0;
            }

            .update-info {
                grid-template-columns: 1fr;
            }

            .idle-grid {
                grid-template-columns: 1fr;
                gap: var(--spacing-md);
            }

            .idle-number {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="app">
        <header class="header">
            <div class="header-content">
                <div class="logo">
                    <h1>Centro de Control de DaiBot</h1>
                    <div class="status-indicator"></div>
                </div>
                <div class="refresh-status">
                    <span class="refresh-indicator" id="refresh-indicator" title="Autoactualización activa"></span>
                    <button class="btn" onclick="manualRefresh()" title="Actualizar ahora">🔄 Actualizar</button>
                </div>
            </div>
        </header>
        <main class="main">
            <div class="global-controls">
                <h2>Controles Globales - Todas las Instancias</h2>
                <div class="control-buttons">
                    <button class="btn btn-success" onclick="sendGlobalCommand('start')">▶️ Iniciar Todo</button>
                    <button class="btn btn-danger" onclick="sendGlobalCommand('stop')">⏹️ Detener Todo</button>
                    <button class="btn btn-warning" onclick="sendGlobalCommand('idle')">⏸️ Poner en Espera</button>
                    <button class="btn" onclick="sendGlobalCommand('resume')">⏯️ Reanudar Todo</button>
                    <button class="btn" onclick="sendGlobalCommand('restart')">🔄 Reiniciar Todo</button>
                    <button class="btn" onclick="sendGlobalCommand('reboot')">🔌 Reinicio Forzado</button>
                    <button class="btn" onclick="sendGlobalCommand('screenon')">💡 Encender Pantalla</button>
                    <button class="btn" onclick="sendGlobalCommand('screenoff')">🌙 Apagar Pantalla</button>
                    <button class="btn btn-primary" onclick="updateAllInstances()">⬆️ Actualizar Todo</button>
                </div>
            </div>
            <div id="instances-container" class="instances-grid">
                <div class="loading"><div class="spinner"></div></div>
            </div>
        </main>
    </div>
    <div id="toast" class="toast">
        <span class="toast-icon"></span>
        <div class="toast-content">
            <div class="toast-title"></div>
            <div class="toast-message"></div>
        </div>
    </div>

    <!-- Update Confirmation Modal -->
    <div id="update-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Actualización disponible</h2>
                <button class="modal-close" onclick="closeUpdateModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="update-info">
                    <div class="version-info">
                        <span class="version-label">Versión actual:</span>
                        <span id="current-version" class="version-value">-</span>
                    </div>
                    <div class="version-info">
                        <span class="version-label">Nueva versión:</span>
                        <span id="new-version" class="version-value version-new">-</span>
                    </div>
                </div>
                <div class="changelog-section">
                    <h3>Registro de cambios</h3>
                    <div id="changelog-content" class="changelog-content">
                        <div class="spinner"></div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeUpdateModal()">Cancel</button>
                <button class="btn btn-primary" onclick="confirmUpdate()">
                    <span>⬆️ Actualizar todas las instancias</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Update Progress Modal -->
    <div id="progress-modal" class="modal">
        <div class="modal-content progress-modal-content">
            <div class="modal-header">
                <h2>Actualización en progreso</h2>
            </div>
            <div class="modal-body">
                <div class="progress-step">
                    <div class="step-icon">⏳</div>
                    <div class="step-info">
                        <div id="progress-status" class="step-title">Preparando actualización...</div>
                        <div id="progress-details" class="step-details"></div>
                    </div>
                </div>

                <div class="progress-bar-container">
                    <div id="progress-bar" class="progress-bar"></div>
                </div>

                <div id="idle-status" class="idle-status" style="display: none;">
                    <div class="idle-grid">
                        <div class="idle-stat">
                            <div class="idle-number" id="bots-idled">0</div>
                            <div class="idle-label">Bots en espera</div>
                        </div>
                        <div class="idle-stat">
                            <div class="idle-number" id="bots-remaining">0</div>
                            <div class="idle-label">Restantes</div>
                        </div>
                        <div class="idle-stat">
                            <div class="idle-number" id="timeout-countdown">300</div>
                            <div class="idle-label">Tiempo de espera (s)</div>
                        </div>
                    </div>

                    <div id="bot-details" class="bot-details"></div>
                </div>

                <div id="update-log" class="update-log"></div>
            </div>
            <div class="modal-footer">
                <button id="force-update-btn" class="btn btn-warning" onclick="forceUpdate()" style="display: none;">
                    ⚡ Forzar actualización ahora
                </button>
            </div>
        </div>
    </div>
    <script>
        const API_BASE = '/api/bot';
        let instances = [];
        let refreshInterval;
        let activeToasts = [];

        let isInteracting = false;
        let refreshPaused = false;
        let lastRefreshTime = Date.now();

        document.addEventListener('DOMContentLoaded', () => {
            refreshInstances();
            startAutoRefresh();
            startConnectionMonitor(); // Add this line

            // Close menus when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.instance-controls')) {
                    document.querySelectorAll('.action-menu.show').forEach(menu => {
                        menu.classList.remove('show');
                    });
                }
            });

            // Track mouse interaction
            document.addEventListener('mouseenter', (e) => {
                if (e.target.closest('.instance-card')) {
                    isInteracting = true;
                }
            }, true);

            document.addEventListener('mouseleave', (e) => {
                if (e.target.closest('.instance-card')) {
                    isInteracting = false;
                }
            }, true);

            // Track touch interaction
            document.addEventListener('touchstart', (e) => {
                if (e.target.closest('.instance-card')) {
                    isInteracting = true;
                }
            });

            document.addEventListener('touchend', () => {
                setTimeout(() => {
                    isInteracting = false;
                }, 500);
            });
        });

        window.addEventListener('beforeunload', () => {
            if (refreshInterval) clearInterval(refreshInterval);
        });

        let updateState = {
            newVersion: '',
            changelog: '',
            instances: [],
            idleCheckInterval: null,
            countdownInterval: null,
            startTime: null,
            timeout: 300,
            forcedUpdate: false
        };

        async function updateAllInstances() {
            // First, check what updates are availableAdd commentMore actions
            showModal('update-modal');

            // Reset state
            updateState = {
                newVersion: '',
                changelog: '',
                instances: [],
                idleCheckInterval: null,
                countdownInterval: null,
                startTime: null,
                timeout: 300,
                forcedUpdate: false
            };

            try {
                // Get current instances first to show version info
                const instancesResponse = await fetch(`${API_BASE}/instances`);
                const instancesData = await instancesResponse.json();
                const currentVersion = instancesData.Instances?.[0]?.Version || 'Unknown';

                document.getElementById('current-version').textContent = currentVersion;
                document.getElementById('new-version').textContent = 'Verificando...';
                document.getElementById('changelog-content').innerHTML = '<div class="spinner"></div>';

                // Check for updates
                const checkResponse = await fetch(`${API_BASE}/update/check`);
                let updateInfo = { version: 'Desconocida', changelog: 'No hay registro de cambios disponible' };

                if (checkResponse.ok) {
                    updateInfo = await checkResponse.json();
                    updateState.newVersion = updateInfo.version;
                    updateState.changelog = updateInfo.changelog || 'No hay registro de cambios disponible';
                } else {
                    // If check endpoint doesn't exist, proceed with a generic update
                    updateState.newVersion = 'Última';
                    updateState.changelog = 'No se pudo obtener el registro de cambios. La actualización continuará a la última versión.';
                }

                document.getElementById('new-version').textContent = updateState.newVersion;
                document.getElementById('changelog-content').textContent = updateState.changelog;

            } catch (error) {
                console.error('Error al verificar actualizaciones:', error);
                document.getElementById('new-version').textContent = 'Última';
                document.getElementById('changelog-content').textContent = 'No se pudo obtener la información de la actualización. Haz clic en Actualizar para continuar.';
            }
        }

        function showModal(modalId) {
            document.getElementById(modalId).classList.add('show');
            document.body.style.overflow = 'hidden';
        }

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('show');
            document.body.style.overflow = '';
        }

        function closeUpdateModal() {
            closeModal('update-modal');
        }

        async function confirmUpdate() {
            closeModal('update-modal');
            showModal('progress-modal');

            updateState.startTime = Date.now();
            updateProgress('Inicializando el proceso de actualización...', 'Verificando todas las instancias para actualizaciones', 10);

            try {
                // Start the idle process
                const response = await fetch(`${API_BASE}/update/all`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ stage: 'start' })
                });

                if (!response.ok) throw new Error('Falló la verificación de actualización');

                const result = await response.json();

                if (result.UpdatesNeeded === 0) {
                    updateProgress('Todas las instancias están actualizadas', 'No se necesitan actualizaciones', 100);
                    addLogEntry('Todas las instancias ya están ejecutando la última versión', 'success');
                    setTimeout(() => {
                        closeModal('progress-modal');
                        showToast('info', 'Sin actualizaciones', 'Todas las instancias ya están actualizadas');
                    }, 2000);
                    return;
                }

                // Store instances that need updates
                updateState.instances = result.Results || [];
                const totalInstances = result.TotalInstances || updateState.instances.length;

                updateProgress(
                    'Preparando instancias para la actualización',
                    `Se encontraron ${result.UpdatesNeeded} instancias que necesitan actualización`,
                    20
                );
                addLogEntry(`Se identificaron ${result.UpdatesNeeded} instancias que requieren actualización`);
                addLogEntry('Enviando comando de espera a todos los bots...', 'info');

                // Show idle status immediately
                document.getElementById('idle-status').style.display = 'block';
                document.getElementById('force-update-btn').style.display = 'inline-flex';

                // Start monitoring idle status
                setTimeout(() => {
                    startIdleMonitoring(totalInstances);
                }, 500);

            } catch (error) {
                console.error('Error al actualizar las instancias:', error);
                updateProgress('Error en la actualización', error.message, 0);
                addLogEntry(`Error en la actualización: ${error.message}`, 'error');

                setTimeout(() => {
                    closeModal('progress-modal');
                    showToast('error', 'Error', 'No se pudo verificar si hay actualizaciones');
                }, 2000);
            }
        }

        function startIdleMonitoring(totalInstances) {
            let lastIdleCount = 0;
            let lastLogTime = 0;

            updateProgress(
                'Esperando que TODOS los bots entren en espera',
                'Todos los bots en todas las instancias deben finalizar sus operaciones actuales antes de actualizar',
                30
            );

            // Update countdown
            updateState.countdownInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - updateState.startTime) / 1000);
                const remaining = Math.max(0, updateState.timeout - elapsed);
                document.getElementById('timeout-countdown').textContent = remaining;

                if (remaining === 0 && !updateState.forcedUpdate) {
                    forceUpdate();
                }
            }, 1000);

            // Check idle status using dedicated endpoint
            updateState.idleCheckInterval = setInterval(async () => {
                try {
                    const response = await fetch(`${API_BASE}/update/idle-status`);
                    const data = await response.json();

                    const totalBots = data.TotalBots || 0;
                    const idledBots = data.TotalIdleBots || 0;
                    const allIdle = data.AllBotsIdle || false;

                    document.getElementById('bots-idled').textContent = idledBots;
                    document.getElementById('bots-remaining').textContent = totalBots - idledBots;

                    // Build detailed status
                    let detailsHtml = '<div style="margin-top: 10px; font-size: 0.8rem;">';
                    let hasNonIdleBots = false;

                    if (data.Instances) {
                        data.Instances.forEach(instance => {
                            if (instance.NonIdleBots && instance.NonIdleBots.length > 0) {
                                hasNonIdleBots = true;
                                detailsHtml += `<div style="margin-bottom: 5px;">Port ${instance.Port}: `;
                                detailsHtml += instance.NonIdleBots.slice(0, 2).map(b =>
                                    `${b.Name} (${b.Status})`
                                ).join(', ');
                                if (instance.NonIdleBots.length > 2) {
                                    detailsHtml += ` +${instance.NonIdleBots.length - 2} more`;
                                }
                                detailsHtml += '</div>';
                            }
                        });
                    }

                    if (!hasNonIdleBots) {
                        detailsHtml = '<div style="color: var(--success); margin-top: 10px;">✅ Todos los bots en todas las instancias están en espera</div>';
                    } else {
                        detailsHtml += '</div>';
                    }

                    document.getElementById('bot-details').innerHTML = detailsHtml;

                    // Log progress when bots idle (but not too frequently)
                    const now = Date.now();
                    if (idledBots > lastIdleCount && now - lastLogTime > 2000) {
                        addLogEntry(`${idledBots}/${totalBots} bots están ahora en espera en todas las instancias`);
                        lastIdleCount = idledBots;
                        lastLogTime = now;

                        // Log which instances still have active bots
                        if (data.Instances) {
                            const activeInstances = data.Instances.filter(i => !i.AllIdle);
                            if (activeInstances.length > 0) {
                                const ports = activeInstances.map(i => i.Port).join(', ');
                                addLogEntry(`Esperando a los bots en los puertos: ${ports}`, 'warning');
                            }
                        }
                    }

                    // Update progress bar
                    const idleProgress = 30 + (idledBots / totalBots) * 40;
                    document.getElementById('progress-bar').style.width = `${idleProgress}%`;

                    // Only proceed if ALL bots are idle
                    if (allIdle && !updateState.forcedUpdate) {
                        clearInterval(updateState.idleCheckInterval);
                        clearInterval(updateState.countdownInterval);
                        addLogEntry('¡Todos los bots en todas las instancias están ahora en espera!', 'success');
                        proceedWithUpdate();
                    }

                } catch (error) {
                    console.error('Error al verificar el estado de espera:', error);
                    // Fall back to old method if new endpoint doesn't exist
                    checkIdleStatusFallback();
                }
            }, 2000);
        }

        // Fallback function for older versions
        async function checkIdleStatusFallback() {
            try {
                const response = await fetch(`${API_BASE}/instances`);
                const data = await response.json();

                let totalBots = 0;
                let idledBots = 0;

                data.Instances.forEach(instance => {
                    if (instance.BotStatuses) {
                        instance.BotStatuses.forEach(bot => {
                            totalBots++;
                            const status = bot.Status.toUpperCase();
                            if (status === 'EN ESPERA' || status === 'DETENIDO') {
                                idledBots++;
                            }
                        });
                    }
                });

                document.getElementById('bots-idled').textContent = idledBots;
                document.getElementById('bots-remaining').textContent = totalBots - idledBots;

                if (idledBots === totalBots && !updateState.forcedUpdate) {
                    clearInterval(updateState.idleCheckInterval);
                    clearInterval(updateState.countdownInterval);
                    proceedWithUpdate();
                }
            } catch (error) {
                console.error('La verificación de espera de respaldo falló:', error);
            }
        }

        async function proceedWithUpdate() {
            updateProgress(
                'Iniciando actualizaciones',
                'Todos los bots están en espera. Comenzando el proceso de actualización...',
                70
            );
            addLogEntry('Todos los bots entraron en espera correctamente. Iniciando actualizaciones...', 'success');

            document.getElementById('idle-status').style.display = 'none';
            document.getElementById('force-update-btn').style.display = 'none';

            try {
                // Call the update endpoint with proceed stage
                const response = await fetch(`${API_BASE}/update/all`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ stage: 'proceed' })
                });

                if (!response.ok) throw new Error('No se pudo continuar con las actualizaciones');

                const result = await response.json();

                // The updates have been triggered, now just show progress
                if (result.UpdatesStarted > 0) {
                    updateProgress(
                        'Actualizaciones en curso',
                        `${result.UpdatesStarted} instancias están siendo actualizadas`,
                        90
                    );

                    // Log each update
                    if (result.Results) {
                        result.Results.forEach(r => {
                            if (r.UpdateStarted) {
                                addLogEntry(`Actualización iniciada en la instancia del puerto ${r.Port}`, 'success');
                            }
                        });
                    }

                    // Check for master updateAdd commentMore actions
                    const masterPort = parseInt(window.location.port || '8080');
                    const masterUpdating = result.Results?.some(r =>
                        r.UpdateStarted && r.Port === masterPort
                    );

                    if (masterUpdating) {
                        masterUpdating = true;
                        setTimeout(() => {
                            updateProgress(
                                'Instancia maestra reiniciándose',
                                'Esta interfaz web se desconectará temporalmente...',
                                95
                            );
                            addLogEntry('La instancia maestra se está actualizando - se espera una desconexión temporal', 'warning');
                        }, 1000);
                    } else {
                        setTimeout(() => {
                            updateProgress(
                                '¡Actualizaciones completas!',
                                'Todas las instancias se han actualizado correctamente',
                                100
                            );
                            addLogEntry('¡Todas las actualizaciones se completaron con éxito!', 'success');

                            setTimeout(() => {
                                closeModal('progress-modal');
                                showToast('success', 'Actualización completa', 'Todas las instancias han sido actualizadas');
                                refreshInstances(true);
                            }, 2000);
                        }, 3000);
                    }
                }
            } catch (error) {
                console.error('Error al continuar con las actualizaciones:', error);
                updateProgress('La actualización falló', error.message, 0);
                addLogEntry(`No se pudo continuar con las actualizaciones: ${error.message}`, 'error');
            }
        }

        function forceUpdate() {
            if (updateState.forcedUpdate) return;

            updateState.forcedUpdate = true;
            clearInterval(updateState.idleCheckInterval);
            clearInterval(updateState.countdownInterval);

            addLogEntry('Se alcanzó el tiempo límite o se forzó la actualización', 'warning');
            updateProgress(
                'Forzando actualización',
                'Continuando con la actualización a pesar de que hay bots activos',
                70
            );

            proceedWithUpdate();
        }

        function updateProgress(status, details, percentage) {
            document.getElementById('progress-status').textContent = status;
            document.getElementById('progress-details').textContent = details;
            document.getElementById('progress-bar').style.width = `${percentage}%`;

            // Update icon based on status
            const iconMap = {
                'Inicializando': '🔍',
                'Preparando': '📋',
                'Esperando': '⏳',
                'Iniciando': '🚀',
                'Actualizando': '📦',
                'Actualizaciones completas': '✅',
                'Error en la actualización': '❌',
                'Forzando': '⚡'
            };

            const icon = Object.entries(iconMap).find(([key]) =>
                status.toLowerCase().includes(key.toLowerCase())
            )?.[1] || '⏳';

            document.querySelector('.step-icon').textContent = icon;
        }

        function addLogEntry(message, type = 'info') {
            const log = document.getElementById('update-log');
            const time = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.innerHTML = `<span class="log-time">${time}</span>${message}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }

        // Connection monitoring
        let connectionLost = false;
        let reconnectInterval = null;
        let masterUpdating = false;

        function startConnectionMonitor() {
            setInterval(async () => {
                try {
                    const response = await fetch(`${API_BASE}/instances`, {
                        method: 'GET',
                        signal: AbortSignal.timeout(2000)
                    });

                    if (!response.ok) throw new Error('Error del servidor');

                    if (connectionLost) {
                        // Connection restored
                        connectionLost = false;
                        handleReconnection();
                    }
                } catch (error) {
                    if (!connectionLost && document.getElementById('progress-modal').classList.contains('show')) {
                        connectionLost = true;
                        handleConnectionLost();
                    }
                }
            }, 1000);
        }

        function handleConnectionLost() {
            if (masterUpdating) return; // Already showing master update UI

            updateProgress(
                'Conexión perdida',
                'Se perdió la conexión con el servidor. Esto puede deberse a que la instancia maestra se está actualizando...',
                -1 // Special value to indicate unknown progress
            );

            // Change progress bar to indeterminate
            document.getElementById('progress-bar').style.width = '100%';
            document.getElementById('progress-bar').style.opacity = '0.5';
            document.getElementById('progress-bar').classList.add('indeterminate');

            addLogEntry('Se perdió la conexión con el servidor - es posible que la instancia maestra se esté actualizando', 'warning');

            // Show reconnection UI
            showReconnectionUI();
        }

        function showReconnectionUI() {
            const modalBody = document.querySelector('#progress-modal .modal-body');

            // Add reconnection status if not already present
            if (!document.getElementById('reconnect-status')) {
                const reconnectDiv = document.createElement('div');
                reconnectDiv.id = 'reconnect-status';
                reconnectDiv.className = 'reconnect-status';
                reconnectDiv.innerHTML = `
                        <div class="reconnect-icon">🔄</div>
                        <div class="reconnect-text">Intentando reconectar...</div>
                        <div class="reconnect-hint">La instancia maestra se está actualizando. Esta página se reconectará automáticamente cuando la actualización haya finalizado.</div>

                    `;
                modalBody.appendChild(reconnectDiv);
            }
        }

        function handleReconnection() {
            addLogEntry('¡Conexión restaurada!', 'success');

            // Remove reconnection UI
            const reconnectStatus = document.getElementById('reconnect-status');
            if (reconnectStatus) {
                reconnectStatus.remove();
            }

            // Reset progress bar
            document.getElementById('progress-bar').classList.remove('indeterminate');
            document.getElementById('progress-bar').style.opacity = '1';

            // Check final update status
            checkFinalUpdateStatus();
        }

        async function checkFinalUpdateStatus() {
            updateProgress(
                'Verificando el estado de la actualización',
                'Comprobando si todas las actualizaciones se completaron correctamente...',
                90
            );

            try {
                const response = await fetch(`${API_BASE}/instances`);
                const data = await response.json();

                // Check versions
                const versions = data.Instances.map(i => i.Version);
                const allSameVersion = versions.every(v => v === versions[0]);

                if (allSameVersion) {
                    updateProgress(
                        '¡Actualizaciones completas!',
                        `Todas las instancias se actualizaron correctamente a la versión ${versions[0]}`,
                        100
                    );
                    addLogEntry(`Todas las instancias ahora están ejecutando la versión ${versions[0]}`, 'success');

                    setTimeout(() => {
                        closeModal('progress-modal');
                        showToast('success', 'Actualización completa', 'Todas las instancias se han actualizado correctamente');
                        refreshInstances(true);
                    }, 3000);
                } else {
                    updateProgress(
                        'Estado de actualización incierto',
                        'Algunas instancias pueden tener versiones diferentes. Por favor, verifica manualmente.',
                        100
                    );
                    addLogEntry('Actualización completada, pero se detectó una discrepancia de versiones', 'warning');
                }
            } catch (error) {
                updateProgress(
                    'No se pudo verificar',
                    'No se pudo comprobar el estado de la actualización. Por favor, verifica las instancias manualmente.',
                    100
                );
            }
        }

        function startAutoRefresh() {
            refreshInterval = setInterval(() => {
                const hasOpenMenu = document.querySelector('.action-menu.show') !== null;
                const timeSinceLastRefresh = Date.now() - lastRefreshTime;
                const indicator = document.getElementById('refresh-indicator');

                // Update indicator
                if (hasOpenMenu || isInteracting || refreshPaused) {
                    indicator.classList.add('paused');
                    indicator.title = 'Auto-refresh paused';
                } else {
                    indicator.classList.remove('paused');
                    indicator.title = 'Auto-refresh active';
                }

                // Only refresh if no menus are open, not interacting, and not manually paused
                if (!hasOpenMenu && !isInteracting && !refreshPaused && timeSinceLastRefresh >= 5000) {
                    refreshInstances();
                }
            }, 1000); // Check every second but only refresh when conditions are met
        }

        async function refreshInstances(isManual = false) {
            try {
                // Don't refresh if menu is open and it's not a manual refresh
                if (!isManual && document.querySelector('.action-menu.show')) {
                    return;
                }

                lastRefreshTime = Date.now();
                const response = await fetch(`${API_BASE}/instances`);
                if (!response.ok) throw new Error('No se pudo obtener las instancias');

                const data = await response.json();
                instances = data.Instances;

                // Only render if no menus are open or it's a manual refresh
                if (!document.querySelector('.action-menu.show') || isManual) {
                    renderInstances();
                }
            } catch (error) {
                console.error('Error al obtener las instancias:', error);
                showError('No se pudieron cargar las instancias del bot. Asegúrate de que el bot esté en ejecución.');
            }
        }

        function renderInstances() {
            const container = document.getElementById('instances-container');

            if (instances.length === 0) {
                container.innerHTML = '<div class="error-message">⚠️ No se encontraron instancias del bot. Asegúrate de que al menos un DaiBot esté en ejecución.</div>';
                return;
            }

            container.innerHTML = instances.map(instance => {
                const isOnline = instance.IsOnline || false;
                const statusClass = isOnline ? 'online' : 'offline';
                const statusIndicator = isOnline ?
                    '<span class="online-indicator"></span>Conectado' :
                    '<span class="offline-indicator"></span>Desconectado';

                let instanceStatus = 'stopped';
                let instanceStatusText = 'Detenido';
                if (instance.BotStatuses && instance.BotStatuses.length > 0) {
                    const runningCount = instance.BotStatuses.filter(b =>
                        b.Status.toUpperCase().includes('EN EJECUCIÓN') ||
                        b.Status.toUpperCase().includes('ACTIVO') ||
                        (!b.Status.toUpperCase().includes('EN ESPERA') &&
                            !b.Status.toUpperCase().includes('DETENIDO') &&
                            !b.Status.toUpperCase().includes('ERROR') &&
                            !b.Status.toUpperCase().includes('DESCONOCIDO'))
                    ).length;

                    const idleCount = instance.BotStatuses.filter(b =>
                        b.Status.toUpperCase().includes('IDLE')
                    ).length;

                    if (runningCount === instance.BotStatuses.length) {
                        instanceStatus = 'running';
                        instanceStatusText = 'Todos en ejecución';
                    } else if (idleCount === instance.BotStatuses.length) {
                        instanceStatus = 'idle';
                        instanceStatusText = 'Todos en espera';
                    } else if (runningCount > 0) {
                        instanceStatus = 'mixed';
                        instanceStatusText = `${runningCount}/${instance.BotStatuses.length} en ejecución`;
                    } else if (idleCount > 0) {
                        instanceStatus = 'idle';
                        instanceStatusText = 'En espera';
                    }
                }

                return `
                    <div class="instance-card ${statusClass}" data-port="${instance.Port}">
                                <div class="instance-header">
                                    <h3 class="instance-title">
                                        ${instance.Name}
                                        <span class="instance-status-badge ${instanceStatus}">${instanceStatusText}</span>
                                    </h3>
                                    <span class="instance-badge">Port ${instance.Port}</span>
                                </div>
                                <div class="instance-body">
                                    <div class="instance-info">
                                        <div class="info-item">
                                            <span class="info-label">Versión</span>
                                            <span class="info-value">${instance.Version}</span>
                                        </div>
                                        <div class="info-item">
                                            <span class="info-label">Modo</span>
                                            <span class="info-value">${instance.Mode}</span>
                                        </div>
                                        <div class="info-item">
                                            <span class="info-label">ID de proceso</span>
                                            <span class="info-value">${instance.ProcessId}</span>
                                        </div>
                                        <div class="info-item">
                                            <span class="info-label">Conexión</span>
                                            <span class="info-value">${statusIndicator}</span>
                                        </div>
                                    </div>

                                    ${instance.BotStatuses && instance.BotStatuses.length > 0 ? `
                                    <div class="bot-status">
                                        <div class="info-label" style="margin-bottom: 0.5rem;">BOTS (${instance.BotStatuses.length})</div>
                                        ${instance.BotStatuses.map((bot, index) => `
                                            <div class="bot-status-item">
                                                <span class="bot-name">
                                                    <span style="color: ${getStatusColor(bot.Status)};">●</span>
                                                    <span>${bot.Name || `Bot ${index + 1}`}</span>
                                                </span>
                                                <span class="bot-state ${getStatusClass(bot.Status)}">${bot.Status}</span>
                                            </div>
                                        `).join('')}
                                    </div>
                                    ` : instance.BotCount > 0 ? `
                                    <div class="bot-status">
                                        <div class="info-label">BOTS</div>
                                        <div class="bot-status-item">
                                            <span class="bot-name">Cantidad de bots: ${instance.BotCount}</span>
                                            <span class="bot-state">Estado desconocido</span>
                                        </div>
                                    </div>
                                    ` : ''}

                                    <div class="instance-controls">
                                        <button class="action-menu-button" onclick="toggleActionMenu(event, ${instance.Port})" ${!isOnline ? 'disabled' : ''}>
                                            ⚡ Acciones <span style="font-size: 0.75rem;">▼</span>
                                        </button>
                                        <div class="action-menu" id="action-menu-${instance.Port}">
                                            <button class="action-menu-item success" onclick="sendInstanceCommand(${instance.Port}, 'start')">
                                                ▶️ Iniciar
                                            </button>
                                            <button class="action-menu-item danger" onclick="sendInstanceCommand(${instance.Port}, 'stop')">
                                                ⏹️ Detener
                                            </button>
                                            <button class="action-menu-item warning" onclick="sendInstanceCommand(${instance.Port}, 'idle')">
                                                ⏸️ Espera
                                            </button>
                                            <button class="action-menu-item" onclick="sendInstanceCommand(${instance.Port}, 'resume')">
                                                ⏯️ Reanudar
                                            </button>
                                            <div class="action-menu-divider"></div>
                                            <button class="action-menu-item" onclick="sendInstanceCommand(${instance.Port}, 'restart')">
                                                🔄 Reiniciar
                                            </button>
                                            <button class="action-menu-item danger" onclick="sendInstanceCommand(${instance.Port}, 'reboot')">
                                                🔌 Reiniciar y detener
                                            </button>
                                            <div class="action-menu-divider"></div>
                                            <button class="action-menu-item" onclick="sendInstanceCommand(${instance.Port}, 'screenon')">
                                                💡 Encender pantalla
                                            </button>
                                            <button class="action-menu-item" onclick="sendInstanceCommand(${instance.Port}, 'screenoff')">
                                                🌙 Apagar pantalla
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        `;
            }).join('');
        }

        function manualRefresh() {
            // Close all menus
            document.querySelectorAll('.action-menu.show').forEach(menu => {
                menu.classList.remove('show');
            });

            // Force refresh
            refreshInstances(true);
            showToast('info', 'Actualizado', 'Instancias del bot actualizadas');
        }

        function toggleActionMenu(event, port) {
            event.stopPropagation();
            const menu = document.getElementById(`action-menu-${port}`);
            const allMenus = document.querySelectorAll('.action-menu');

            // Close all other menus
            allMenus.forEach(m => {
                if (m.id !== `action-menu-${port}`) {
                    m.classList.remove('show');
                }
            });

            // Toggle current menu
            const wasOpen = menu.classList.contains('show');
            menu.classList.toggle('show');

            // Update interaction state
            isInteracting = !wasOpen;

            // If we just closed the last menu, allow refresh again
            if (wasOpen && !document.querySelector('.action-menu.show')) {
                isInteracting = false;
            }
        }

        function getStatusColor(status) {
            const upperStatus = status?.toUpperCase() || '';
            if (upperStatus.includes('EN EJECUCIÓN') || upperStatus.includes('ACTIVO') ||
                (!upperStatus.includes('EN ESPERA') && !upperStatus.includes('DETENIDO') && !upperStatus.includes('ERROR') && !upperStatus.includes('DESCONOCIDO'))) {
                return '#10b981'; // Verde - activo
            } else if (upperStatus.includes('EN ESPERA') || upperStatus.includes('PAUSA')) {
                return '#f59e0b'; // Amarillo - inactivo o pausado
            } else if (upperStatus.includes('DETENIDO') || upperStatus.includes('DESCONECTADO') || upperStatus.includes('REINICIANDO')) {
                return '#ef4444'; // Rojo - detenido o error
            } else if (upperStatus.includes('ERROR')) {
                return '#ef4444'; // Rojo - error
            } else {
                return '#6b7280'; // Gris - desconocido
            }
        }

        function getStatusClass(status) {
            const upperStatus = status?.toUpperCase() || '';
            if (upperStatus.includes('EN EJECUCIÓN') || upperStatus.includes('ACTIVO') ||
                (!upperStatus.includes('EN ESPERA') && !upperStatus.includes('DETENIDO') && !upperStatus.includes('ERROR') && !upperStatus.includes('DESCONOCIDO'))) {
                return 'running';
            } else if (upperStatus.includes('EN ESPERA') || upperStatus.includes('PAUSA')) {
                return 'idle';
            } else if (upperStatus.includes('DETENIDO') || upperStatus.includes('REINICIANDO') || upperStatus.includes('DESCONECTADO') || upperStatus.includes('ERROR')) {
                return 'stopped';
            } else {
                return 'error';
            }
        }

        async function sendGlobalCommand(command) {
            showToast('info', 'Enviando Comando', `Enviando ${command} a todas las instancias...`);

            try {
                const response = await fetch(`${API_BASE}/command/all`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ Command: command })
                });

                if (!response.ok) throw new Error('Fallo al enviar el comando');

                const result = await response.json();
                const successCount = result.SuccessfulCommands || 0;
                const totalCount = result.TotalInstances || 0;

                if (successCount === totalCount && totalCount > 0) {
                    showToast('success', 'Comando Enviado', `Comando ${command} enviado correctamente a las ${totalCount} instancias`);
                } else if (successCount > 0) {
                    showToast('warning', 'Éxito Parcial', `Comando ${command} enviado a ${successCount} de ${totalCount} instancias`);
                } else {
                    showToast('error', 'Fallo', `No se pudo enviar el comando a ninguna instancia`);
                }

                setTimeout(() => refreshInstances(true), 1000);
            } catch (error) {
                console.error('Error al enviar el comando global:', error);
                showToast('error', 'Error', `No se pudo enviar el comando: ${command}`);
            }
        }

        async function sendInstanceCommand(port, command) {
            // Close action menu
            document.getElementById(`action-menu-${port}`).classList.remove('show');

            // Clear interaction state
            isInteracting = false;

            showToast('info', 'Enviando Comando', `Enviando ${command} a la instancia en el puerto ${port}...`);

            try {
                const response = await fetch(`${API_BASE}/instances/${port}/command`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ Command: command })
                });

                if (!response.ok) throw new Error('Command failed');

                const result = await response.json();
                if (result.Success) {
                    showToast('success', 'Comando Enviado', `Comando ${command} enviado correctamente a la instancia en el puerto ${port}`);
                } else {
                    showToast('error', 'Fallo', result.Message || 'Error desconocido');
                }

                setTimeout(() => refreshInstances(true), 1000);
            } catch (error) {
                console.error(`Error al enviar el comando al puerto ${port}:`, error);
                showToast('error', 'Error', `No se pudo enviar el comando a la instancia en el puerto ${port}`);
            }
        }

        function showError(message) {
            console.error(message);
            showToast('error', 'Error', message);
        }

        function showToast(type, title, message) {
            const toastId = Date.now();
            const toast = document.getElementById('toast').cloneNode(true);
            toast.id = `toast-${toastId}`;

            const icon = toast.querySelector('.toast-icon');
            const titleEl = toast.querySelector('.toast-title');
            const messageEl = toast.querySelector('.toast-message');

            titleEl.textContent = title;
            messageEl.textContent = message;

            toast.className = 'toast';
            switch (type) {
                case 'success':
                    icon.textContent = '✅';
                    toast.classList.add('success');
                    break;
                case 'error':
                    icon.textContent = '❌';
                    toast.classList.add('error');
                    break;
                case 'warning':
                    icon.textContent = '⚠️';
                    toast.classList.add('warning');
                    break;
                case 'info':
                default:
                    icon.textContent = 'ℹ️';
                    toast.classList.add('info');
                    break;
            }

            document.body.appendChild(toast);
            activeToasts.push(toastId);

            // Adjust position for multiple toasts
            const toastHeight = 80; // Approximate height including margin
            const bottomOffset = activeToasts.indexOf(toastId) * toastHeight;

            if (window.innerWidth <= 768) {
                toast.style.bottom = `${bottomOffset}px`;
            } else {
                toast.style.bottom = `${32 + bottomOffset}px`;
            }

            // Force reflow before adding show class
            toast.offsetHeight;

            requestAnimationFrame(() => {
                toast.classList.add('show');
            });

            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => {
                    toast.remove();
                    activeToasts = activeToasts.filter(id => id !== toastId);

                    // Reposition remaining toasts
                    activeToasts.forEach((id, index) => {
                        const remainingToast = document.getElementById(`toast-${id}`);
                        if (remainingToast) {
                            if (window.innerWidth <= 768) {
                                remainingToast.style.bottom = `${index * toastHeight}px`;
                            } else {
                                remainingToast.style.bottom = `${32 + index * toastHeight}px`;
                            }
                        }
                    });
                }, 300);
            }, 4000);
        }
    </script>
</body>
</html>
